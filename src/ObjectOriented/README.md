# 面向对象的程序设计
```
js中没有类的概念，因此跟传统OO的语言有所不同
```
## 理解对象

### 什么是对象
```
ECMA-262对象的定义： 无序属性的集合，其属性可以包含基本值，对象或者函数。
                   每个对象都是基于一个引用类型创建的
```

### 属性类型
```
ECMAScript中有两种属性： 数据属性和访问器属性

什么是数据属性？
数据属性包含一个数据值的位置，从这个位置可以读取和写入值，数据属性有4个描述其行为的4个特性

1 [[Configurable]]  能否通过delete删除属性，修改属性的特性，能否吧属性修改为访问器属性 默认为true
2 [[Enumerable]]  是否可以for...in 默认为true
3 [[Writable]]  是否能修改属性的值  默认为true
4 [[Value]]  包含这个属性的数据值，默认为undefined

在调用Object.defineProperty()时  若不指定数据属性的特性 除[[Value]]外都是false

为什么IE8上不能使用Object.defineProperty()?
IE8这个方法只作用域DOM, 而且只能创建访问器属性

什么是访问器属性？
访问器属性不包含数据值，它们包含一堆getter，setter函数，访问器属性有4个特性

1 [[Configurable]]  能否通过delete删除属性，修改属性的特性，能否吧属性修改为访问器属性 默认为true
2 [[Enumerable]]  是否可以for...in 默认为true
3 [[Set]]  在写入属性时调用的函数 默认值为undefined
4 [[Get]]  在读取属性时调用的函数 默认值为undefined

访问器属性不能直接定义，必须使用Object.defineProperty()来定义

在不支持Object.defineProperty()方法的浏览器中，不能修改[[Configurable]]和[[Enumerable]]

一个元素的属性只能是其中一种，要么是数据属性要么是访问器属性

注意：
设置访问器属性的属性名，在set函数中避免使用同名，避免导致循环调用而栈溢出
```

## 创建对象
### 为什么需要创建对象？
```
Object的构造函数或者对象字面量都可以创建对象，但这种方式存在一个缺点，每次创建对象都会产生大量的代码
```
### 工厂模式
```
在函数内部创建一个对象，然后对该对象赋值，最后返回这个对象
存在的问题：无法知道创建对象的类型
```
### 构造函数模式
```

与工厂模式的区别
1 没有显式的创建对象
2 直接将属性赋值给了this
3 没有return语句

要创建构造函数的实例，必须要通过new操作符，这种方式调用构造函数会经过4个步骤
1 创建一个新的对象
2 将构造函数的作用域赋值给新对象，（this指向该对象）
3 执行构造函数的代码 （对新对象属性进行赋值）
4 返回该对象

instanceOf
实例 instanceOf 构造函数
判断实例和构造函数的关系

意味着构造函数的实例可以标识为一种特定的类型

存在的问题：
每个方法都需要在新的实例上创建一遍

解决办法：
全局声明函数，构造函数内使用其引用
这样又会产生新的问题
如果构造函数需要定义很多的方法，那么就需要声明很多的全局函数，这样降低了封装性

```

### 原型模式
```
通过构造函数的原型对象来进行属性和方法的共享（包括constructor属性）

什么是原型对象？
只要创建了一个函数，就会根据一组特定的规则为该函数创建一个prototype属性，该属性指向函数的原型对象

构造函数，原型对象，实例的关系？
构造函数的prototype属性指向原型对象 原型对象的constructor属性指向构造函数 实例的__proto__属性指向原型对象

原型对象.isPrototypeOf(实例对象)
判断原型对象和实例对象的关系

in操作符和原型的关系？
in的两种使用方式
属性 in 对象 
for (var key in 对象)

使用in时，属性会从实例对象 =》 原型对象上找

for...in, 返回的是能够通过对象访问的，可枚举的属性
IE低版本的bug 在实例中屏蔽在原型上是不可枚举的属性 如toString()

ES5 Object.keys(实例对象) 返回 [property1, property2]

原型的动态性？
在原型上查找值是一个搜索过程，即使先生成实例，再修改原型对象的属性，实例依然可以访问到后修改的属性。

原型对象的问题？
属性共享，导致每个实例没有独立的属性
```

### 组合使用构造函数模式和原型模式
```
使用两种模式的优点，构造函数保证属性的独立，原型对象使得方法的共享
```

### 动态原型模式
```
类似传统OO将属性和方法都包含在构造函数中，不同的是通过判断方法属性是否为方法，如果不是则向原型对象上添加方法
```

### 寄生构造模式
```
创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象（跟工厂模式相同）
使用场景：创建一个具有特殊方法的数组，而不改变原生数组的原型对象

注意：产生的实例跟构造函数没有什么关系 
```

### 稳妥构造函数模式
```
于寄生构造模式类似，不定义属性，构造函数的参数会作为私有变量供其方法使用，保证安全性。
稳妥对象：没有公共属性，而且其方法也不引用this的对象

使用场景：安全环境（禁用new或者this）或者防止数据被其他应用程序（[Mashup程序](https://msdn.microsoft.com/zh-cn/library/bb906060.aspx) 改动时使用

注意：产生的实例跟构造函数没什么关系
```

## 继承

### 原型链
```
什么是原型链？


怎么使用原型链？
子类的原型对象 = new 父类

为什么使用原型链？
为了实现继承，利用原型让一个引用类型继承另一个引用类型的属性和方法

实现继承的方式？
接口继承和实现继承
JS只有实现继承（依赖原型链）


如何确定原型和实例的关系？
1 instanceof    instance instanceof Object 
instaceof 用来判断构造函数的原型对象是否存在于实例的原型链上

2 isPrototypeOf Object.prototype.isPrototypeOf(instance)


直接使用原型链继承的问题？
1 父类的引用属性共享 （如定义在父类的数组）
2 创建子类时，不能向父类的构造函数传递参数
```

### 借用构造函数
```
什么是借用构造函数？
借用构造函数也称伪造对象或者经典继承，通过子类调用父类的构造函数来实现

借用构造函数怎么用？
通过call() apply()在子类构造函数调用父类的构造函数

为什么需要借用构函数？
1 解决原型链中引用类型带来的问题
2 可以向父类构造函数传递参数

借用构造函数的问题？
函数复用的问题
```


### 组合继承
```
什么是组合继承（伪经典继承）？
原型链继承 + 借用构造函数继承

组合继承怎么用？
1 子类使用call() apply() 调用父类的构造函数
2 子类的原型对象 = new 父类构造函数

为什么需要用组合继承？
融合了原型链继承和借用构造函数继承的优点，成为了最常用的继承模式

存在的问题？
会调用两次父类的构造函数 （子类构造函数中，子类原型）
```


### 原型式继承
```
什么是原型式继承？
借助原型基于已有对象创建对象

原型式继承怎么用？
object.create()

为什么要用原型式继承？
不用创建构造函数，就可以实现一个对象和另一对象保持一致

存在的问题？
引用类型的属性会共享
```

### 寄生式继承
```
什么是寄生式继承？
与工厂模式类似，创建一个用于封装继承过程的函数，函数内部以某种方式来增强对象，最后再返回对象

寄生式继承怎么用？

为什么用寄生式继承？

存在的问题？
函数不能共享
```

### 寄生组合式继承
```
什么是寄生组合式继承？
通过借用构造函数来继承属性，通过原型链的混成形式来继承方法

寄生组合继承怎么用？
在组合继承的模式下，修改创建子类原型的方法

为什么使用寄生组合继承？
减少父类构造函数的次数，同时也减少子类的原型不需要的属性

寄生组合模式是引用类型最理想的继承范式
```


