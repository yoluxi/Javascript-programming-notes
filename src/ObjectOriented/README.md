# 面向对象的程序设计
```
js中没有类的概念，因此跟传统OO的语言有所不同
```
## 理解对象

### 什么是对象
```
ECMA-262对象的定义： 无序属性的集合，其属性可以包含基本值，对象或者函数。
                   每个对象都是基于一个引用类型创建的
```

### 属性类型
```
ECMAScript中有两种属性： 数据属性和访问器属性

什么是数据属性？
数据属性包含一个数据值的位置，从这个位置可以读取和写入值，数据属性有4个描述其行为的4个特性

1 [[Configurable]]  能否通过delete删除属性，修改属性的特性，能否吧属性修改为访问器属性 默认为true
2 [[Enumerable]]  是否可以for...in 默认为true
3 [[Writable]]  是否能修改属性的值  默认为true
4 [[Value]]  包含这个属性的数据值，默认为undefined

在调用Object.defineProperty()时  若不指定数据属性的特性 除[[Value]]外都是false

为什么IE8上不能使用Object.defineProperty()?
IE8这个方法只作用域DOM, 而且只能创建访问器属性

什么是访问器属性？
访问器属性不包含数据值，它们包含一堆getter，setter函数，访问器属性有4个特性

1 [[Configurable]]  能否通过delete删除属性，修改属性的特性，能否吧属性修改为访问器属性 默认为true
2 [[Enumerable]]  是否可以for...in 默认为true
3 [[Set]]  在写入属性时调用的函数 默认值为undefined
4 [[Get]]  在读取属性时调用的函数 默认值为undefined

访问器属性不能直接定义，必须使用Object.defineProperty()来定义

在不支持Object.defineProperty()方法的浏览器中，不能修改[[Configurable]]和[[Enumerable]]

一个元素的属性只能是其中一种，要么是数据属性要么是访问器属性

注意：
设置访问器属性的属性名，在set函数中避免使用同名，避免导致循环调用而栈溢出
```

## 创建对象
### 为什么需要创建对象？
```
Object的构造函数或者对象字面量都可以创建对象，但这种方式存在一个缺点，每次创建对象都会产生大量的代码
```
### 工厂模式
```
在函数内部创建一个对象，然后对该对象赋值，最后返回这个对象
存在的问题：无法知道创建对象的类型
```
### 构造函数模式
```

与工厂模式的区别
1 没有显式的创建对象
2 直接将属性赋值给了this
3 没有return语句

要创建构造函数的实例，必须要通过new操作符，这种方式调用构造函数会经过4个步骤
1 创建一个新的对象
2 将构造函数的作用域赋值给新对象，（this指向该对象）
3 执行构造函数的代码 （对新对象属性进行赋值）
4 返回该对象

instanceOf
实例 instanceOf 构造函数
判断实例和构造函数的关系

意味着构造函数的实例可以标识为一种特定的类型

存在的问题：
每个方法都需要在新的实例上创建一遍

解决办法：
全局声明函数，构造函数内使用其引用
这样又会产生新的问题
如果构造函数需要定义很多的方法，那么就需要声明很多的全局函数，这样降低了封装性

```

### 原型模式
```
通过构造函数的原型对象来进行属性和方法的共享（包括constructor属性）

什么是原型对象？
只要创建了一个函数，就会根据一组特定的规则为该函数创建一个prototype属性，该属性指向函数的原型对象

构造函数，原型对象，实例的关系？
构造函数的prototype属性指向原型对象 原型对象的constructor属性指向构造函数 实例的__proto__属性指向原型对象

原型对象.isPrototypeOf(实例对象)
判断原型对象和实例对象的关系

in操作符和原型的关系？
in的两种使用方式
属性 in 对象 
for (var key in 对象)

使用in时，属性会从实例对象 =》 原型对象上找

for...in, 返回的是能够通过对象访问的，可枚举的属性
IE低版本的bug 在实例中屏蔽在原型上是不可枚举的属性 如toString()

ES5 Object.keys(实例对象) 返回 [property1, property2]

原型的动态性？
在原型上查找值是一个搜索过程，即使先生成实例，再修改原型对象的属性，实例依然可以访问到后修改的属性。

原型对象的问题？
属性共享，导致每个实例没有独立的属性
```

### 组合使用构造函数模式和原型模式
```
使用两种模式的优点，构造函数保证属性的独立，原型对象使得方法的共享
```

### 动态原型模式
```
类似传统OO将属性和方法都包含在构造函数中，不同的是通过判断方法属性是否为方法，如果不是则向原型对象上添加方法
```

### 寄生构造模式
```
创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象（跟工厂模式相同）
使用场景：创建一个具有特殊方法的数组，而不改变原生数组的原型对象

注意：产生的实例跟构造函数没有什么关系 
```

### 稳妥构造函数模式
```
于寄生构造模式类似，不定义属性，构造函数的参数会作为私有变量供其方法使用，保证安全性。
稳妥对象：没有公共属性，而且其方法也不引用this的对象

使用场景：安全环境（禁用new或者this）或者防止数据被其他应用程序（[Mashup程序](https://msdn.microsoft.com/zh-cn/library/bb906060.aspx) 改动时使用

注意：产生的实例跟构造函数没什么关系
```